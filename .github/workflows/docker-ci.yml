name: DevEnv Docker Image

on:
  push:
    branches:
      - master
    tags:
      - devenv-v*
  workflow_dispatch:

concurrency:
  # Cancel unfinished CI/CD runs if a new run starts on the same branch.
  group: ${{ github.workflow }}-${{ github.head_ref || github.ref_name }}
  cancel-in-progress: true

env:
  PLATFORMS: linux/amd64  #,linux/arm64/,linux/arm32
  TEMP_IMAGE_NAME: localhost:5000/${{ github.repository }}/dev-env:ci
  GHCR_IMAGE_NAME: ghcr.io/${{ github.repository }}/dev-env

jobs:
  check_build:
    name: Check if we should build a new docker image.
    runs-on: ubuntu-24.04
    outputs:
      do_build: ${{ steps.check.outputs.do_build }}
    steps:
      - name: Checkout
        uses: actions/checkout@v6
        with:
          # Only metadata of 2 most recent commits is necessary below.
          fetch-depth: 2
          sparse-checkout: nix-da

      - name: Check if there were changes that warrant a build`
        id: check
        run: |
          if [[ $GITHUB_REF == refs/tags/devenv-v* ]]; then
            # Tagging always runs the build.
            echo "Got tag ${GITHUB_REF#/refs/tags/} - will build"
            echo "do_build=true" >> "$GITHUB_OUTPUT"
          elif [[ "$GITHUB_EVENT_NAME" == "workflow_dispatch" ]]; then
            # Manual runs always run the build.
            echo "Manual start - will build"
            echo "do_build=true" >> "$GITHUB_OUTPUT"
          elif git diff --name-only HEAD~1 | grep -q '^docker/'; then
            # Commits run the build if docker/* was touched.
            echo "Committed docker/* files - will build"
            echo "do_build=true" >> "$GITHUB_OUTPUT"
          else
            echo "No relevant changes - won't build"
            echo "do_build=false" >> "$GITHUB_OUTPUT"
          fi

  sanitize:
    name: Sanitize env vars
    runs-on: ubuntu-24.04
    outputs:
      temp_image_name: ${{ steps.lower.outputs.temp_image_name }}
      ghcr_image_name: ${{ steps.lower.outputs.ghcr_image_name }}
    steps:
      - name: Lowercase env vars
        id: lower
        run: |
          echo "temp_image_name=${TEMP_IMAGE_NAME,,}" >> "$GITHUB_OUTPUT"
          echo "ghcr_image_name=${GHCR_IMAGE_NAME,,}" >> "$GITHUB_OUTPUT"

  build:
    name: Build and test docker image
    needs: [check_build,sanitize]
    if: needs.check_build.outputs.do_build == 'true'
    runs-on: ubuntu-24.04
    permissions:
      contents: read       # Required for the 'actions/checkout' step
      packages: write      # Allows pushing/writing to GHCR
    env:
      TEMP_IMAGE_NAME: ${{ needs.sanitize.outputs.temp_image_name }}
      GHCR_IMAGE_NAME: ${{ needs.sanitize.outputs.ghcr_image_name }}

    services:
      registry:
        # Ephemeral docker registry for storing images between build and test.
        image: registry:2
        ports:
          - 5000:5000
    steps:
      - name: Checkout
        uses: actions/checkout@v6

      - name: Setup Bats and bats libs
        id: setup-bats
        uses: bats-core/bats-action@3.0.1

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3
        with:
          platforms: ${{ env.PLATFORMS }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          driver-opts: network=host

      - name: Login to GitHub Container Registry (GHCR)
        uses: docker/login-action@v3
        with:
          # Persistent docker registry for publishing the image.
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Prepare image metadata
        id: meta
        run: |
          PUSH_TO_GHCR=false
          # Determine the Docker container tags.
          TAGS=""

          if [[ $GITHUB_REF == refs/tags/devenv-v* ]]; then
            PUSH_TO_GHCR=true
            # Git tags are used as docker image tags with 'devenv-' stripped.
            VERSION=${GITHUB_REF#refs/tags/devenv-}
            TAGS="${{ env.GHCR_IMAGE_NAME }}:${VERSION}"

            if [[ $VERSION =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
               # Apply semantic version (semver) expansion, i.e., latest X.Y.Z
               # also becomes X.Y and X
               V=${VERSION:1}
               MAJOR_MINOR=${V%.*}
               MAJOR=${MAJOR_MINOR%.*}
               TAGS="$TAGS,${{ env.GHCR_IMAGE_NAME }}:v${MAJOR_MINOR}"
               TAGS="$TAGS,${{ env.GHCR_IMAGE_NAME }}:v${MAJOR}"
            fi

          elif [[ $GITHUB_REF == 'refs/heads/master' ]]; then
            PUSH_TO_GHCR=true
            # Git main branch commits are tagged with docker's default 'latest'
            # tag.
            VERSION=latest
            TAGS="${{ env.GHCR_IMAGE_NAME }}:${VERSION}"
          fi

          if [[ $GITHUB_REF == refs/tags/* ]]; then
             IMAGE_VERSION=${VERSION#v}
          else
          IMAGE_VERSION="git-${GITHUB_SHA:0:7}"
          fi

          echo "::group::Image metadata"
          echo "PUSH_TO_GHCR=${PUSH_TO_GHCR}"
          echo "VERSION=${VERSION}"
          echo "TAGS=${TAGS}"
          echo "IMAGE_VERSION=${IMAGE_VERSION}"
          echo "::endgroup::"

          {
            echo "push_to_ghcr=${PUSH_TO_GHCR}"
            echo "image_version=${IMAGE_VERSION}"
            echo "tags=${TAGS}"
          } >> "$GITHUB_OUTPUT"

      - name: Build development environment image
        uses: docker/build-push-action@v5
        with:
          context: docker
          platforms: ${{ env.PLATFORMS }}
          push: true
          tags: ${{ env.TEMP_IMAGE_NAME }}
          build-args: |
            IMAGE_VERSION=${{ steps.meta.outputs.image_version }}

      - name: Inspect image manifest
        id: inspect
        run: |
          # Get the metadata of all platform images from the multi-platform
          # manifest of the above build.
          docker buildx imagetools inspect ${{ env.TEMP_IMAGE_NAME }}
          echo "raw=$(docker buildx imagetools inspect --raw \
            ${{ env.TEMP_IMAGE_NAME }} \
            | tr -d '\n')" >> "$GITHUB_OUTPUT"

      - name: Test image
        env:
          BATS_LIB_PATH: ${{ steps.setup-bats.outputs.lib-path }}
        run: |
          # Do a test build on all architectures.
          # Get digest and architecture of each manifest in multi-platform
          # image.
          digests=(${{ join(
            fromJSON(steps.inspect.outputs.raw).manifests.*.digest,
            ' '
          ) }})
          architectures=(${{ join(
            fromJSON(steps.inspect.outputs.raw).manifests.*.platform.
                architecture,
            ' '
          ) }})
          if [[ "${#digests[@]}" -ne "${#architectures[@]}" ]]; then
            echo "::error::Digest and arch array lengths do not match:" \
                 "[${architectures[*]}] [${digests[*]}]"
            exit 1
          fi
          for ((i=0; i<${#digests[@]}; i++)); do
            digest="${digests[i]}"
            arch="${architectures[i]}"
            echo "Digest: ${digest}"
            echo "Architecture: ${arch}"
            # The multi-platform docker image contains a bunch of manifests, but
            # only the ones that have an valid architecture are manifests of
            # platform sub-images we can actually run.
            if [[ "${arch}" == 'unknown' ]]; then
              echo '... skipping metadata image'
              continue
            fi
            # Run the test suite on one architecture.
            export DOCKER_IMAGE="${{ env.TEMP_IMAGE_NAME }}@${digest}"
            echo "Running tests on image ${DOCKER_IMAGE}..."
            docker pull "${DOCKER_IMAGE}"
            docker run --rm -v .:/Cwerg "${DOCKER_IMAGE}" \
                sh -c 'echo Testing image on $(uname -m)...'
            echo "=========== would run BATS now ==========="
            #bats -j "$(nproc)" --trace docker/tests
          done

      - name: Push to GHCR
        if: steps.meta.outputs.push_to_ghcr == 'true'
        run: |
          # Split the comma-separated tags and format them as arguments
          IFS=',' read -ra TAG_ARRAY <<< "${{ steps.meta.outputs.tags }}"
          TAG_ARGS=""
          for tag in "${TAG_ARRAY[@]}"; do
            TAG_ARGS="$TAG_ARGS -t $tag"
          done

          # Use imagetools create to copy the multi-platform image from the
          # local registry to GHCR.
          # This avoids rebuilding the image and ensures the exact image tested
          # is pushed.
          # shellcheck disable=SC2086
          docker buildx imagetools create $TAG_ARGS ${{ env.TEMP_IMAGE_NAME }}
